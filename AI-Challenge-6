# Write a function that can generate all the Pythagorean triples up to a limit for the value of c (hypotenuse).
# You'll need to utilize Euclid's Formula (a = k(m^2 - n^2), b = k(2mn), c = k*(m^2+n^2)).
# You'll need to find all primitive and non-primitive triples and eliminate duplicates, and try to be efficient.
# Difficulty: intermediate

# My solution:
import math

def generator(m, n, k):
    a = k * (m**2 - n**2)
    b = k * (2*m*n)
    c = k * (m**2 + n**2)
    return a, b, c

def pyth_triple_gen(max_c):
    max_m = round(math.sqrt(max_c-1))
    max_n = max_m -1
    max_k = round(max_c/5)
    m = 2
    n = 1
    k = 1
    m_list = [2]
    n_list = [1]
    k_list = [1]
    m_n_k_list = []
    triple_list = []
    while k < max_k:
        k += 1
        k_list.append(k)
    while m < max_m:
        m += 1
        m_list.append(m)
    while n < max_n:
        n += 1
        n_list.append(n)
    for m in m_list:
        for n in n_list:
            if n < m:
                for k in k_list:
                    m_n_k_list.append((m, n, k))

    for m, n, k in m_n_k_list:
        current_triple = generator(m, n, k)
        if current_triple[-1] <= max_c:
            triple_list.append(current_triple)
    sorted_triple_list = [tuple(sorted(tup)) for tup in triple_list]
    return set(sorted_triple_list)

# AI's optimized solution (I tweaked some errors):
import math

def pyth_triple_gen_optimize(max_c):
    max_m = int(math.sqrt(max_c-1))
    triples = []
    for m in range(2, max_m + 1):
        for n in range(1, m):
            k = 1
            while True:
                c = k*(m**2 + n**2)
                if c > max_c:
                    break
                a = k*(m**2 - n**2)
                b = k*(2*(m*n))
                triples.append((a, b, c))
                k += 1
    sorted_triples = [tuple(sorted(tup)) for tup in triples]
    return set(sorted_triples)

